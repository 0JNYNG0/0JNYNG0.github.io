---
title:  "[Android] Room DB 사용해보기" 
excerpt: "Android Study"

categories:
  - Android
tags:
  - [Android]

toc: true
toc_sticky: true
 
date: 2022-12-20
last_modified_at: 2022-12-20
---
```
하나씩 차근차근 개인적으로 공부한 것을 기록하는 블로그입니다.
참고하시고 잘못되거나 고쳐야 할 부분이 있다면 지적 부탁드립니다!
읽어주셔서 감사합니다🙂
```

## 기본 세팅 - 의존성 추가
Room DB를 사용하기 위해 build.gradle 내용 수정을 먼저 해야한다.<br>

```kotlin
plugins {
    //

    id 'kotlin-kapt'  // 추가
}

dependencies {
    //

    implementation "androidx.room:room-runtime:x.x.x"  // 추가
    kapt "androidx.room:room-compiler:x.x.x"  // 추가
}
```
plugins, dependencies에 각각 코드를 추가해주고 의존성의 **"x.x.x"** 버전은 구글 검색창에 ***Android Room***을 검색 후 최신 버전을 찾아 적어주면 된다.<br>
<br><br>

## 필요한 파일 생성

### 테이블 생성
***
예시로, model이라는 폴더를 만들고 History.kt 데이터 클래스 파일(원하는 이름 사용)을 생성해준다.<br>

```kotlin
@Entity
data class History(
    @PrimaryKey val uid: Int?,
    @ColumnInfo(name = "expression") val expression: String?,
    @ColumnInfo(name = "result") val result: String?
)
```
<br><br>

### Dao 추가
***
- Dao(Data Access Object)란?<br>
    데이터베이스의 data에 접근하기 위한 객체로, 로직 & 비즈니스 로직을 분리하기 위해 사용한다.<br>

예시로, dao라는 폴더를 만들고 HistoryDao.kt 인터페이스 파일을 생성해준다.<br>

```kotlin
@Dao
interface HistoryDao {
		
    @Query("SELECT * FROM history")
    fun getAll(): List<History>

    @Insert
    fun insertHistory(history: History)

    @Query("DELETE FROM history")
    fun deleteAll()

    // Additional ex. 추가로 제거, 조건이 달린 SELECT 등 사용방법이 다양하다.

    // @Delete
    // fun delete(history: History)

    // @Query("SELECT * FROM history WHERE result LIKE :result LIMIT 1")
    // fun findByResult(result: String): History

}
```
- @Query라는 쿼리 어노테이션을 붙여 원하는 DB 작업을 실행하도록 한다.
- 또한, Insert와 Delete 등 다른 작업도 가능하다.

<br><br>

### Database 생성
***
AppDatabase.kt라는 파일을 생성해준다.<br>

```kotlin
@Database(entities = [History::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun historyDao(): HistoryDao
}
```

- Database 어노테이션 @Database()에 사용하고자 하는 데이터베이스 클래스와 버전을 명시해주도록 한다.
- RoomDatabase()를 상속받는 추상 클래스로 만들고, 그 안에 이전에 만들었던 Dao 인터페이스를 상속받는 abstract 함수 또한 만들어준다.
<br><br>

## 액티비티에서 RoomDB 사용하기
MainActivity에서 앞서 만들어줬던 클래스, 인터페이스를 사용해보자.<br>

```kotlin
lateinit var db: AppDatabase

override fun onCreate(savedInstanceState: Bundle?) {
		super.onCreate(savedInstanceState)
		setContentView(R.layout.activity_main)
		
		db = Room.databaseBuilder(
				applicationContext,
				AppDatabase::class.java,
				"historyDB"
		).build() // Database build
}
```
- 먼저 AppDatabase의 변수를 하나 만들고 build()해야 한다.<br>
    - Room.databaseBuilder()에는 순서대로 Context, 데이터베이스 클래스.java, 사용할 이름을 넣어주고 build()를 통해 변수 db에 데이터베이스를 할당해주자.
<br><br>

그리고 본격적으로 DB에 대한 처리를 할 때는 꼭 메인스레드가 아닌 <u>새로운 Thread를 열어 작업을 진행</u>시켜줘야 함을 명심하자. 메인스레드에서 무거운 작업을 할 경우 앱이 죽을 수 있기 때문이다.<br><br><br><br><br>


이제 DB에 값을 넣어주는 Insert 작업을 해보자.
```kotlin
val expressionText = expressionTextView.text.toString()
val resultText = calculateExpression()

Thread(Runnable {
    db.historyDao().insertHistory(History(null, expressionText, resultText))
}).start()
```
위 코드는 DB에 값을 Insert하는 코드이다. DB에 앞서 만든 History라는 데이터 클래스의 새로운 테이블을 하나 집어넣도록 하고 이는 꼭 새로운 스레드 위에서 진행되어야 한다.<br>
- db의 abstract 함수인 historyDao()를 통해 HistoryDao 인터페이스에 접근하고 그 안의 insertHistory()라는 인터페이스 함수를 사용하는 과정이다.
- History()의 첫 번째 인자값은 @PrimaryKey 어노테이션으로 지정한 값인데 이는 하나씩 생성될 때마다 자동으로 값이 1씩 올라가도록 처리되기 때문에 null값을 넣어줘도 무방하다.
<br><br><br><br>


```kotlin
fun historyButtonClicked(v: View) {
    historyLayout.isVisible = true
    historyLinearLayout.removeAllViews() // 해당 LinearLayout의 모든 뷰 삭제

    // DB에서 모든 기록 가져오기
    // 뷰에 모든 기록 할당하기
    Thread(Runnable {
        db.historyDao().getAll().reversed().forEach {
            runOnUiThread {
                val historyView = LayoutInflater.from(this).inflate(R.layout.history_row, null, false)
                historyView.findViewById<TextView>(R.id.expressionTextView).text = it.expression
                historyView.findViewById<TextView>(R.id.resultTextView).text = "= ${it.result}"

                historyLinearLayout.addView(historyView) 
                // 새로운 뷰를 만들어서 값을 할당하고 레이아웃에 해당 뷰를 추가하는 작업
            }
        }
    }).start()
}

fun historyClearButtonClicked(v: View) {
    historyLinearLayout.removeAllViews()
		
    Thread(Runnable {
        db.historyDao().deleteAll()
    }).start()
}
```
위 코드에서는 historyButtonClicked함수에서 DB 내 모든 값들을 가져오고 historyClearButtonClicked 함수에서 DB 내 모든 값들을 삭제하는 작업을 한다.<br>
- `db.historyDao().getAll().reversed()` -> db라는 데이터베이스에서 HistoryDao 인터페이스에 접근하여 getAll()이라는 인터페이스 함수를 이용해 모든 값을 가져온 다음 reversed()로 역순의 데이터를 받아오는 코드이다.
- `db.historyDao().deleteAll()` -> 마찬가지로 HistoryDao 인터페이스 함수인 deleteAll()로 모든 데이터를 삭제시키는 코드이다.

<br><br><br>

이처럼 간단하게 Room DB 사용 예시를 알아보았다.<br>
데이터를 다룰 테이블, DB의 데이터에 접근하기 위한 Dao, 사용할 DB 이렇게 3개의 파일을 만들어준다음 DB를 빌드하고 DB와 연결된 Dao에 접근 및 인터페이스 함수들을 이용해 DB 데이터 처리를 하는 과정이 이루어진다. 이 과정을 이해하고 많이 사용해보도록 하자.
<br><br><br>